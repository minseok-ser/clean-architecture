## 계층으로 구성하기
패키지가 ```domain```, ```persistence```, ```web```으로 구성   
app의 기능조각이나 특성을 구분짓는 패키지 경계가 없다.   
모든 컨트롤러는 ```web```에 있고, 모든 서비스는 ```domain```에 있고, 영속성은 ```persistence```에 있고... 예상치 못한 부수효과   
이런 이름으로는 어떤 기능(유스케이스)가 구현되어 있는지 파악 불가능   

## 기능으로 구성하기
모두 account 기능이니까 일단 ```account```에 집어넣었다   
서비스의 이름을 ```SendMoneyService```로 변경 - 유스케이스에 기반한 이름붙이기   
의존성 역전 - ```domain```에 인터페이스, ```persistence```에 구현체
어댑터 패키지와 포트 패키지도 없어서 가시성도 떨어진다   

## 표현력 있는 패키지 구조
엔티티, 유스케이스, 포트, 어댑터를 중심으로 구성   
```account``` - ```adapter```, ```domain```, ```application```   
```adapter``` - ```in/web```, ```out/persistence```: 어댑터   
```domain```: 도메인 모델   
```application``` - ```port``` - ```in```, ```out```: 포트 인터페이스   

아키텍처와 코드 사이의 간극을 효과적으로 해결하는 패키지 구조   
```adapter``` 패키지는 ```application```의 포트 인터페이스를 통하지 않고 바로 접근할 수 없다   
```application```과 ```domain``` 패키지는 일부 클래스를 ```public```으로 지정 - 어댑터에서 접근 가능해야 함   
서비스는 인커밍 포트 뒤에 있으므로 ```public``` 불필요   
DDD (domain driven design) 비즈니스 도메인별로 나누어 설계하는 디자인   
bounded context 비즈니스 도메인의 대상을 고유한 비즈니스 목적별로 그룹핑. 영역 경계 내에서 동일한 모델을 일관되게 사용. 맥락을 형성하는 어떤 범위를 말한다.

## 의존성 주입의 역할
```application```이 ```adapter```에 의존성을 갖지 않아야 함   
outgoing adapter에 대해서 의존성 역전을 사용   
포트 초기화를 app 계층에서 수동으로 하지 않으려면?: 모든 계층에 의존성을 가진 컴포넌트에서 아키텍처를 구성하는 클래스를 초기화
